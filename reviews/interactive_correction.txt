Summary
The authors 
They illustrate this with the expression problem.

Significance and Originality
This is an exceedingly difficult problem to tackle well, and I commend the authors for having the ambition to take it on. Successfully tackling it could potentially result in significant improvements to the human process of interactive program and proof development. Is it really something we care about a solution to though? Are we happy just accepting that extensions require significant reconsidering? Their example would be handled with no additional effort just by making the modifications and letting the typechecker tell you what to fix. Tools to aid program modification are a worthwhile pursuit, but I think this paper fails to present any significant or intriguing advances in this direction.

- Paper should make an effort to justify that this is a reasonable problem. It's stated, but not explained
For example: when extending a term language like they do in their example, one must often also extend typing rules for that language simultaneously; it is unlikely that one extension can be carried out completely before the other. I think this is a barrier to this tool being practically useful. Such mutually dependent extensions are very common, and the authors fail to even mention that this might be a concern, let alone address it.

The ideas in their solution are quite obvious: they can be summed up as "When adding a constructor, extend occurrences of pattern matching. When adding constructor parameters, extend applications of the constructor". I would expect 

My understanding is that if the user runs into a limitation (e.g. must add parameters), the extension process will simply fail and the user must resort to manual edits.

Limitations: only lets me fill in terms; no extra function parameters or simultaneous extensions, often these kinds of changes cause cascades (okay dependencies can be handled backwards maybe, but mutual dependency is a real concern). If the authors anticipate that these will not be cause for concern, I would like to see justification why.

The restrictions are severe and . The examples they give are toy examples. Considering toy examples are trivial to extend manually, the primary benefit of tools such as these is in large developments. I need to see evidence that this tool is applicable and useful in larger developments before I'm convinced. I expect that many of these restrictions will have to be relaxed.


I am not convinced of the tool's utility and applicability. I consider it limited in application until proven otherwise.

e.g. "Definition invalid := exp_rec"...

There are ad-hoc restrictions: in Section 3.3, page 9, they explain that the tool only permits adding new constructor parameters *after* old parameters. This suggests that the syntax for constructor extensions is insufficient and should provide a way to map the old parameters to the new.

They have an implementation, which is nice, but I think it is premature and that there is still much to be worked out in the design of such a tool.

Their work is limited to operate on proof terms? Eh, I'm okay with it.. Suggest Agda

In the example they present (extending an arithmetic language with multiplication), it is just as easy to perform this extension manually: Add the appropriate constructor, and let the typechecker tell you where the resultant missing cases are. I need to be convinced that the tool can improve this process, and this example fails to do so.

My understanding is that if an extension requires anything but the most trivial of changes (adding a branch to a pattern match), the extension process fails and the user must manually perform the extension. It seems to me that this will be extremely common in non-trivial examples (e.g. perhaps we need a modified induction invariant). If the authors believe that this will not be an issue, they must explain why.

Quality of Presentation

I think that a demonstration of the workflow in developing an extended (non-toy) example would benefit this paper. The reader would like to see how this tool improves their process of writing more realistic examples for the reasons outlined above. 

Section 3.3: It is not clear what "ECoq tries to minimize inconsistent parts" means.

Section 3.3: the choice of example for "Extend Constructor" is poor: it results in "No inconsistent parts are detected". The reader would like to see an example of what constitutes an "inconsistent part" and what happens in this case. 

Section 5.3 is poorly written and it is not clear why these citations are made. This section could be removed or shorted to a sentence.

- Prop hierarchy is not standard terminology.. careful

The paper has many grammatical errors and poorly worded sentences (partial list follows) and requires more careful proof reading.

pg 1. "What we have to do here is to..." is awkward in the abstract
pg 1. "it is so hard" maybe "it is very hard"
pg 2. "This will be serious flaws"
pg 2. "commands that extends" should be "commands that extend"
pg 2. "Message shown here" should be "Messages shown here"
pg 2. "ECoq shows where should be modified"
pg 3. "One more" is awkward
pg 6. "In Coq, many comfortable" perhaps "In Coq, many convenient"
pg 6. "pros" should be "pro" and "cons" should be "con"
pg 6. "too much parts" should be "too many parts"
pg 7. "expressions who destructs" maybe "expressions which destruct"
pg 7. "source codes" should be "source code"
pg 7. "For example, execute function" should be "For example, the execute function"
pg 7. "an constructor" should be "a constructor"
pg 8. "roof-editing"
pg 9. "massage"
pg 10. "The rest output is similar..." is unclear and awkward
pg 11. "will get troubles" is awkward
pg 11. "to ensure extractions"?
pg 12. "enough loose" maybe "loose enough"
pg 12. "that sort as a result sort of the type" is unclear
pg 12. "the type whose type is one of sorts or sort with parameters is said an arity" is unclear
pg 12. "sort polymorphism is to replace" is awkward
pg 13. "enable to insert any types' elements"
pg 13. "arities of Type make complex dependent types" is unclear
pg 13. "corresponding inconsistent" maybe "corresponding to inconsistent parts"
pg 13. "ECoq explore" should be "ECoq explores"
pg 13. "view point" should be "viewpoint" (everywhere)
pg 14. "recursions for polymorphic variants unusual ways"

Suitability
The paper introduces a tool to support the maintenance of Coq proofs, and hence loosely falls within the domain of CPP. However, I think it lacks emphasis on the tool's application to proofs. All but one of the examples given are directly applicable to ML programs. There is very little discussion of the interaction of the tool with dependent types and proofs.

Overall
This paper fails to convince me that it is significant. The examples usages are just as easily done (and more flexibly done) by extending datatypes manually and allowing the typechecker to identify what needs to be fixed. Furthermore, the limitations of the tool suggest to me that it will not scale to non-trivial examples. If the authors believe that it will scale and provide tangible benefit beyond what the typechecker already provides, then they must directly address this in the paper. The relationship to proofs is not adequately illustrated for CPP and there are many errors in the authors' use of English. For these reasons, I recommend the paper be rejected. 
