Summary
The authors 

Significance and Originality
This is an exceedingly difficult problem to tackle well, and I commend the authors for having the ambition to take it on. Successfully tackling it could result in a significant improvements to the human process of interactive program and proof development. Could it? It seems that using such a tool requires an "up front" view of how to modify the program? (Refactoring works; the process is to incrementally change your program with semantic-preserving stuff until it's easy to make a non-semantic preserving change). Is it really something we care about a solution to though? Are we happy just accepting that extensions require significant reconsidering? Their example would be handled with no additional effort just by making the modifications and letting the typechecker tell you what to fix. Tools to aid program modification are a worthwhile pursuit, but I think this paper fails to present any significant or intriguing advances in this direction.

- Paper should make an effort to justify that this is a reasonable problem. It's stated, but not explained
For example: when extending a term language like they do in their example, one must often also extend typing rules for that language simultaneously; it is unlikely that one extension can be carried out completely before the other. I think this is a barrier to this tool being practically useful. Such mutually dependent extensions are very common, and the authors fail to even mention that this might be a concern, let alone address it.

The ideas in their solution are quite obvious: they can be summed up as "When adding a constructor, extend occurrences of pattern matching. When adding constructor parameters, extend applications of the constructor". I would expect 

My understanding is that if the user runs into a limitation (e.g. must add parameters), the extension process will simply fail and the user must resort to manual edits.

Limitations: only lets me fill in terms; no extra function parameters or simultaneous extensions, often these kinds of changes cause cascades (okay dependencies can be handled backwards maybe, but mutual dependency is a real concern). If the authors anticipate that these will not be cause for concern, I would like to see justification why.

The restrictions are severe and . The examples they give are toy examples. Considering toy examples are trivial to extend manually, the primary benefit of tools such as these is in large developments. I need to see evidence that this tool is applicable and useful in larger developments before I'm convinced. I expect that many of these restrictions will have to be relaxed.


I am not convinced of the tool's utility and applicability. I consider it limited in application until proven otherwise.
What does this offer beyond the typechecker which points out these errors for you?
e.g. "Definition invalid := exp_rec"...

There are ad-hoc restrictions: in Section 3.3, page 9, they explain that the tool only permits adding new constructor parameters *after* old parameters. This suggests that the syntax for constructor extensions is insufficient and should provide a way to map the old parameters into the new.

Can't this drastically change the structure of proof terms? e.g. what if we have to change the format from a destruct to an inversion?

They have an implementation, which is nice, but I think it is premature and that there is still much to be worked out in the design of such a tool.

More advanced example? Dependent types?

Their work is limited to operate on proof terms? Eh, I'm okay with it.. Suggest Agda

Quality of Presentation

For work such as this, whose primary concern is usability, I would appreciate a demonstration of the workflow of developing an extended (non-toy) example with this tool.

Section 3.3: It is not clear what "ECoq tries to minimize inconsistent parts" means.

Section 3.3: the choice of example for "Extend Constructor" is poor: it results in "No inconsistent parts are detected". The reader would like to see an example of what constitutes an "inconsistent part" and what happens in this case. 

Section 5.3 is poorly written and it is not clear why these citations are made. This section could be removed or shorted to a sentence.

- Prop hierarchy is not standard terminology.. careful

The paper has many grammatical errors and poorly worded sentences (partial list follows) and requires more careful proof reading.

pg 1. "What we have to do here is to..." is awkward in the abstract
pg 1. "it is so hard" -- maybe "it is very hard"
pg 2. "This will be serious flaws"
pg 2. "commands that extends" should be "commands that extend"
pg 2. "Message shown here" should be "Messages shown here"
pg 2. "ECoq shows where should be modified"
pg 3. "One more" is awkward
pg 6. "In Coq, many comfortable" perhaps "In Coq, many convenient"
pg 6. "pros" should be "pro" and "cons" should be "con"
pg 6. "too much parts" should be "too many parts"
pg 7. "expressions who destructs" maybe "expressions which destruct"
pg 7. "source codes" should be "source code"
pg 7. "For example, execute function" should be "For example, the execute function"
pg 7. "an constructor" should be "a constructor"
pg 8. "roof-editing"
pg 9. "massage"
pg 10. "The rest output is similar..." is unclear and awkward
pg 11. "will get troubles" is awkward
pg 11. "to ensure extractions"?
pg 12. "enough loose" maybe "loose enough"
pg 12. "that sort as a result sort of the type" is unclear
pg 12. "the type whose type is one of sorts or sort with parameters is said an arity" is unclear
pg 12. "sort polymorphism is to replace" is awkward
pg 13. "enable to insert any types' elements"
pg 13. "arities of Type make complex dependent types" is unclear
pg 13. "corresponding inconsistent" maybe "corresponding to inconsistent parts"
pg 13. "ECoq explore" should be "ECoq explores"
pg 13. "view point" should be "viewpoint" (everywhere)
pg 14. "recursions for polymorphic variants unusual ways"

Suitability?

OAAO might be interesting to the authors?

(Identify good things in paper. It's not to comfort the authors, it's so they know what to keep).
