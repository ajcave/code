Summary
The authors 

Significance and Originality
This is an exceedingly difficult problem to tackle well, and I commend the authors for having the ambition to take it on. Successfully tackling it could result in a significant improvements to the human process of interactive program and proof development. Could it? It seems that using such a tool requires an "up front" view of how to modify the program? (Refactoring works; the process is to incrementally change your program with semantic-preserving stuff until it's easy to make a non-semantic preserving change). Is it really something we care about a solution to though? Are we happy just accepting that extensions require significant reconsidering? Their example would be handled with no additional effort just by making the modifications and letting the typechecker tell you what to fix. Tools to aid program modification are a worthwhile pursuit, but I think this paper fails to present any significant or intriguing advances in this direction.

- Paper should make an effort to justify that this is a reasonable problem. It's stated, but not explained
For example: when extending a term language like they do in their example, one must often also extend typing rules for that language simultaneously; it is unlikely that one extension can be carried out completely before the other. I think this is a barrier to this tool being practically useful. Such mutually dependent extensions are very common, and the authors fail to even mention that this might be a concern, let alone address it.

The ideas in their solution are quite obvious: they can be summed up as "When adding a constructor, extend occurrences of pattern matching. When adding constructor parameters, extend applications of the constructor". I would expect 

My understanding is that if the user runs into a limitation (e.g. must add parameters), the extension process will simply fail and the user must resort to manual edits.

Limitations: only lets me fill in terms; no extra function parameters or simultaneous extensions, often these kinds of changes cause cascades (okay dependencies can be handled backwards maybe, but mutual dependency is a real concern). If the authors anticipate that these will not be cause for concern, I would like to see justification why.

The restrictions are severe and . The examples they give are toy examples. Considering toy examples are trivial to extend manually, the primary benefit of tools such as these is in large developments. I need to see evidence that this tool is applicable and useful in larger developments before I'm convinced. I expect that many of these restrictions will have to be relaxed.


I am not convinced of the tool's utility and applicability. I consider it limited in application until proven otherwise.
What does this offer beyond the typechecker which points out these errors for you?
e.g. "Definition invalid := exp_rec"...

There are ad-hoc restrictions: in Section 3.3, page 9, they explain that the tool only permits adding new constructor parameters *after* old parameters.

Can't this drastically change the structure of proof terms? e.g. what if we have to change the format from a destruct to an inversion?

They have an implementation, which is nice, but I think it is premature and that there is still much to be worked out in the design of such a tool.

More advanced example? Dependent types?

Their work is limited to operate on proof terms? Eh, I'm okay with it.. Suggest Agda

Quality of Presentation

For work such as this, whose primary concern is usability, I would appreciate a demonstration of the workflow of developing an extended (non-toy) example with this tool.

Section 3.3: It is not clear what "ECoq tries to minimize inconsistent parts" means.

Section 3.3: the choice of example for "Extend Constructor" is poor: it results in "No inconsistent parts are detected". The reader would like to see an example of what constitutes an "inconsistent part" and what happens in this case. 

The paper has many grammatical errors (some listed below) and desperately requires more careful proof reading.

- Prop hierarchy is not standard terminology.. careful

Suitability?

OAAO might be interesting to the authors?

(Identify good things in paper. It's not to comfort the authors, it's so they know what to keep).
