\documentclass[usenames,dvipsnames]{beamer}
\setbeamertemplate{footline}[frame number]
\usepackage{alltt}

\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\usepackage{ textcomp }
\usepackage{array}

\usepackage{srcltx}
\usepackage[tikz]{bclogo}


\providecommand{\term}[1]{\mbox{\small{\textsf{#1}}}}

\newcommand{\const}[1]{\textbf{#1}}
\newcommand{\bnfas}{\mathrel{::=}}
\newcommand{\bnfalt}{\mathrel{\mid}}
\newcommand{\arrow}{\to}
\newcommand{\lam}[1]{\lambda #1. }
\usepackage{proof}
\newcommand{\entails}{\vdash}
\newcommand{\der}{\vdash}
\newcommand{\stepsto}{\longrightarrow}
\newcommand{\id}{\text{id}}
\setbeamertemplate{itemize item}{\scriptsize\raise1.25pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{itemize subitem}{\tiny\raise1.5pt\hbox{\donotcoloroutermaths$\bullet$}}
\setbeamertemplate{itemize subsubitem}{\tiny\raise1.5pt\hbox{\donotcoloroutermaths$-$}}
\definecolor{light-gray}{gray}{0.5}

\author{Andrew Cave}
\title[{\makebox[.45\paperwidth]{Dependent Type Theory for Contextual Reasoning\hfill%
       \insertframenumber/\inserttotalframenumber}}]{Dependent Type Theory for Contextual Reasoning} 
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Introduction}
\begin{itemize}
\item Proofs can be long and error-prone to check by hand
\pause
\item e.g. Feit Thompson theorem: proof spans 2 books, 350 pages
\pause
\item Lots of work on languages for machine-checkable proofs (Automath, Mizar, Coq, ...)
\pause \item {\color{green} Pro:} machine-checked proofs can be easier to trust
\pause \item {\color{green} Pro:} coming up with proofs can be \emph{interactive}
% \begin{itemize}
% \item System: ``Goal is X''
% \item Human prover: ``Use lemma foo''
% \item System: ``New subgoals: Y and Z''
% \end{itemize}
\pause \item {\color{red} Con:} on paper we like to elide details
\begin{itemize}
\item How can we do the same for machine-checked formalizations?
% \item Need to somehow equip proof checker with domain-specific procedures
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Introduction cont'd}
\begin{itemize}
\item Proofs in programming language theory: prime
candidates for formalization?
\begin{itemize}
\item Inductive reasoning is well understood
\item Lots of cases! Can be
tedious and error-prone to write \& verify by hand.
\end{itemize}
\pause
\item Burdensome part: giving a formal treatment of variable binding and
substitution.
\end{itemize}
\pause
\begin{quote}
When doing the formalization, I discovered that the core part of the
proof [...] is fairly straightforward and
only requires a good understanding of the paper version. However, in
completing the proof I observed that in certain places I had to invest
much more work than expected, e.g. proving lemmas about substitution
and weakening. -- Thorsten Altenkirch, 1993

   (formalizing normalization of System F)
\end{quote}
% \pause
% \begin{itemize}
% \item 20 years later: This proof still hasn't been done in a less painful way(?!)
% \end{itemize}
\end{frame}

\begin{frame}{Thesis}
\begin{quote}Building a logical framework into dependent type
theory is possible and makes mechanization of state-of-the-art programming
language metatheory more effective.
\end{quote}
\begin{itemize}
\pause
\item More generally: Learn some lessons on how
to make mechanization of proofs outside of programming languages and
logic more practical?
\end{itemize}
\end{frame}

\begin{frame}{Background: Higher-order abstract syntax}
\begin{itemize}
\item Lots of approaches to support binding and substitution
\item Higher-order abstract syntax (HOAS) one of the most effective
\begin{itemize}
\item Idea: represent binding and substitution using functions and application from a meta-language
\end{itemize}
\item The logical framework LF is well-suited for representing
programming language syntax, logics and hypothetical
judgments using HOAS
\item Twelf [Pfenning and Sch\"urmann '99] implements LF
\begin{itemize}
\item Very effective for basic results in programming language theory (type soundness, confluence)
% \item Less clear how to formulate induction
% over HOAS representations
\item Steep price: very weak logic. Can only express $\forall\exists$ statements
% \item Abella: first order logic (weak)
% \item Hybrid, nominal logic, locally nameless, etc: less support for substitution
\item Cannot express advanced results (normalization, parametricity)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Background: Dependent type theory [Martin-L\"of '73]}
\begin{itemize}
\item Very rich logic (on par with set theory and higher-order logic)
% \item Approaches to logics/languages for
% machine checked proofs: Higher order logic, set theory, and dependent
% type theory
\item Comes equipped with a direct
connection to computer programming.
\item Rich environment supports both proofs and programs.
\item A proof is an algorithm!
\item Theory and implementation, hand in hand
% \item Intensional dependent type theory includes a decidable equational theory
\item Can, in principle, express advanced results, but...
\item No direct support for substitution
\end{itemize}
\end{frame}

\begin{frame}{Background: Two-level approaches}
\begin{itemize}
\item A two-level approach as in Abella [Gacek'08], Beluga [Pientka'08], Delphin [Poswolsky and Sch\"urmann '08] looks promising
\begin{itemize}
\item HOAS representation on one level (e.g. LF)
\item Rich logic/type theory at the next
\end{itemize}
\item Abella, Beluga, Delphin are roughly indexed type theory/first-order logic with induction
\item Still not enough to directly express advanced results in programming language theory...
\pause \item Question: can we have dependent type theory?
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Motivating Example: Proof by logical relations}{Simply-typed lambda calculus definition}
\begin{tabular}{p{2.8cm}l}
\fbox{Syntax}\vfill &
\begin{array}[t]{lrcl}
\mbox{Types} & A,B & \bnfas & {\const b} \bnfalt A \arrow B \\
\mbox{Terms} & M,N & \bnfas & {\const c} \bnfalt x \bnfalt \lam x M \bnfalt M\;N \\
\mbox{Values} & V & \bnfas & {\const c} \bnfalt \lam x M
\end{array}
\\[3em]
\pause
\vspace{-2.3em}\fbox{Typing $\Gamma \vdash M : A$} &
\begin{array}[t]{l}
\infer{\Gamma \vdash x : A}{\Gamma(x) = A} \quad
\infer{\Gamma \entails \lam x M : A \arrow B}{\Gamma,x{:}A \der M : B}
\\[0.4em]
\infer{\Gamma \entails {\const c} : {\const b}}{}
\quad
\infer{\Gamma \entails M\; N : B}{\Gamma \entails M : A \arrow B \quad \Gamma \entails N : A}
\end{array}
\\[3em]
\pause
\vspace{-2.3em}\fbox{Op. Sem.} & 
$\infer{M\;N \stepsto M'\;N}{M \stepsto M'} \quad \infer{(\lam x M) N \stepsto [N/x]M}{} $ \\[2em]
\end{tabular}

\hfill $M$ halts if $\exists V.\, M \stepsto^* V$ \hfill
\end{frame}

\begin{frame}[fragile]{Motivating Example: Proof by logical relations}{Weak normalization}
\begin{itemize}
\item Goal: If $\vdash M : A$ then $M$ halts
\begin{enumerate}
\item Define predicate $\mathcal{R}_A$
% \item Show if $M' \in \mathcal{R}_A$ and $M \stepsto M'$ then $M \in \mathcal{R}_A$
\item If $M \in \mathcal{R}_A$ then $M$ halts
\item If $\vdash M : A$ then $M \in \mathcal{R}_A$
\pause

Generalize: {\color{purple}If $\Gamma \vdash M : A$ and $\sigma \in \mathcal{R}_\Gamma$ then $[\sigma]M \in \mathcal{R}_A$}

(where $\Gamma$ of the form $x_1{:}B_1,...,x_n{:}B_n$ and $\sigma$ of the form $N_1/x_1,...,N_n/x_n$ and $\sigma \in \mathcal{R}_\Gamma$ means $N_1 \in \mathcal{R}_{B_1},...,N_n \in \mathcal{R}_{B_n}$)
\end{enumerate}
\pause \item Representative of wide variety of advanced proofs (logical relations)
\end{itemize}
% We prove the more general result that every term of type $A$ is \textbf{reducible} at type $A$, where reducibility is defined:
% \[
% \begin{array}{l}
% \mathcal{R}_{\const i} = \{M\; |\; M \text{ halts}\} \\
% \mathcal{R}_{A \arrow B} = \{M\; |\; M \text{ halts and } \forall N
% \in \mathcal{R}_A, (M\; N) \in \mathcal{R}_B \}
% \end{array}
% \]

% \pause
% \begin{lemma}[Backward closure]
% If $M' \in \mathcal{R}_A$ and $M \stepsto M'$ then $M \in \mathcal{R}_A$
% \end{lemma}
\end{frame}

\begin{frame}{Motivating Example: Proof by logical relations}{Definition of $\mathcal{R}$}
\[
\begin{array}{l}
\mathcal{R}_{\const b} = \{M\; |\; M \text{ halts}\} \\
\mathcal{R}_{A \arrow B} = \{M\; |\; M \text{ halts and } \forall N
\in \mathcal{R}_A, (M\; N) \in \mathcal{R}_B \}
\end{array}
\]
\end{frame}

\begin{frame}{Motivating Example: Proof by logical relations}

\begin{theorem}
If $\Gamma \vdash M : A$ and $\sigma \in \mathcal{R}_\Gamma$ then
$[\sigma]M \in \mathcal{R}_A$.
\end{theorem}
\pause
\begin{proof}
By induction. 
Case $\begin{array}{l}\infer{\Gamma \der \lam x M : A \arrow
    B}{\Gamma,x{:}A \der M : B}\end{array}$: Given $N \in \mathcal{R}_A$.

\begin{enumerate}
\pause \item $(\sigma,N/x) \in \mathcal{R}_{\Gamma,x:A}$ \hfill (by definition)
\pause \item $[\sigma,N/x]M \in \mathcal{R}_B$ \hfill (by I.H.)
\pause \item {\color{purple} $[\sigma,N/x]M = [N/x][\sigma,x/x]M$ \hfill (property of substitution)}
\pause \item $[N/x][\sigma,x/x]M \in \mathcal{R}_B$ \hfill (previous lines)
\pause \item $(\lam x ([\sigma,x/x]M))\; N \longrightarrow [N/x][\sigma,x/x]M$ \hfill ($\beta$ reduction)
\pause \item $(\lam x ([\sigma,x/x]M))\; N \in \mathcal{R}_B$ \hfill (backward closure)
\pause \item $(\lam x ([\sigma,x/x]M)) \in \mathcal{R}_{A \arrow B}$ \hfill (by definition)
\pause \item {\color{purple} $[\sigma](\lam x M) \in \mathcal{R}_{A \arrow B}$ \hfill (property of substitution)}
\end{enumerate}
\end{proof}
\end{frame}

% \begin{frame}{Motivating Example: Proof by logical relations}{Problems to solve in a formalization}
% \begin{itemize}
% \item Representing binding: $\lambda x. M$?
% \item Definition of $\mathcal{R}$?
% \item Definition of substitution $[\sigma]M$?
% \item Quantification over contexts $\Gamma$?
% \item Proving equations: $[N/x][\sigma,x/x]M = [\sigma,N/x]M$?
% \end{itemize}
% \end{frame}

\newcommand{\good}{{\color{green}\textbf{\checkmark}}}
\newcommand{\bad}{{\color{red}\textbf{\xmark}}}
\newcommand{\ok}{{\color{orange}$\mathbf{\sim}$}}

\begin{frame}[fragile]{Support from proof environments}
\begin{tabular}{| p{4.4cm} | l | l | l |}
\hline
 & Type theory & Twelf & Two-level \\
 & (Coq) & & (Beluga) \\ \hline
Def. Binding: $\lambda x. M$ & \ok & \good & \good \\ \hline
Ind. predicates e.g. $\mathcal{R}_{\Gamma}$ & \good & \bad & \only<1>{?}\only<2>{\good$^1$} \\ \hline
Def. of $\mathcal{R}_A$ & \good & \bad & \only<1>{?}\only<2>{\ok$^1$} \\ \hline
Def. subst. $[N/x]M$ & \ok & \good & \good \\ \hline
Def. subst. $[\sigma]M$ & \ok & \ok & \only<1>{?}\only<2>{\good$^2$} \\ \hline
Quantify over contexts & \good & \bad & \good \\ \hline
Equations e.g. \begin{small}$[N/x][\sigma,x/x]M = [\sigma,N/x]M$\end{small} & \bad & \ok & \only<1>{?}\only<2>{\good$^2$} \\ \hline
Reasoning about functions & \good & \bad & ? \\ \hline
\end{tabular}

$\,$

\only<2>{$^1$ Indexed recursive types [Cave and Pientka POPL'12]

$^2$ First-class substitutions [Cave and Pientka LFMTP'13]}
\end{frame}

% \begin{frame}{Motivating Example: Proof by logical relations}{Properties of substitution}
% \begin{itemize}
% \item First, names are tricky.
% \item de Bruijn indices tend to work better for brute-force formalization than names
% \begin{lemma}
% $[N/x][\sigma,x/x]M = [\sigma,N/x]M$ (provided $x$ fresh for $\sigma$)
% \end{lemma}
% becomes
% \begin{lemma}
% $[ id , N ] [ \uparrow \sigma, 1 ] M = [ \sigma , N ] M$
% \end{lemma}
% \end{itemize}
% % \begin{lemma}
% %  [ [ \(\sigma1\) ]' \(\sigma2\) ] = [ \(\sigma1\) ] \(\circ\) [ \(\sigma2\) ]
% % \end{lemma}
% % lem2 : [ \(\sigma\) , M ] \(\circ\) \(\uparrow\) = [ \(\sigma\) ]
% % lem3 : [ id ]' \(\sigma\) = \(\sigma\)
% % lem4 : [ id , N ] \(\circ\) [ \(\uparrow\) \(\sigma\), 1 ] = [ \(\sigma\) , N ]
% % ...
% % \end{alltt}
% This is tedious to do for each language we study!
% \end{frame}


% \begin{frame}{My progress to date}
% \begin{itemize}
% \item Indexed recursive types [Cave and Pientka '12]:  
% \begin{itemize}
% \item Part way to supporting definition of $\mathcal{R}$
% \end{itemize}
% \item First-class substitutions [Cave and Pientka '13]:
% \begin{itemize}
% \item 
% \end{itemize}
% \end{itemize}
% \end{frame}

\begin{frame}{Progress to date}{Indexed recursive types [Cave and Pientka POPL'12]}
\begin{itemize}
\item Adds LF-indexed recursive types to two-level system
\item Richer forms of induction
\item Can express forms of predicates that LF can't e.g.
\begin{itemize}
\item certain subexpressions are \emph{closed}
\item relations between contexts
\end{itemize}
\item Technical result: type soundness and decidability of typechecking
\item Implemented in the Beluga system
\item Good for \emph{programming}
\item Not so good for \emph{reasoning}: naive treatment is logically inconsistent
\item Allows us to experiment with defining logical relations
\item Not ideal: relations between contexts are typically \emph{functional} relations: why not treat them as \emph{functions}
\end{itemize}
\end{frame}

\begin{frame}{Progress to date}{First class substitutions [Cave and Pientka LFMTP'13]}
\begin{itemize}
\item Adds special built-in type of simultaneous substitutions $\sigma$
\item Equational theory is \textbf{built-in} to type checking: user does not need to prove any equations about substitutions
\item Technical result: decidability of typechecking including equational theory of substitutions
\item Example application: Allows us to write remarkably succinct logical relations proof of weak normalization
\begin{itemize}
\item Uses ``unsound in general'' recursive types to define logical relation
\item Future work: fix this
\end{itemize}
% \item Convenient for logical relations: need to quantify over ``closing substitutions''
% \begin{theorem}[Fundamental theorem]
% If $\Gamma \vdash M : A$ {\color{purple} and $\sigma \in \mathcal{R}_\Gamma$} then
% $[\sigma]M \in \mathcal{R}_A$.
% \end{theorem}
% \item New equations to solve: $[N/x][\sigma,x/x]M = [\sigma,N/x]M$ provided $x \not\in fv(\sigma)$
\end{itemize}
\end{frame}

\begin{frame}{Progress to date}{Logical relations in contextual type theory (draft)}
\begin{itemize}
\item Formalizes more involved logical relations proof (completeness of an algorithmic equality for simply-typed lambda calculus)
\item Proof is ``easy'': lemmas about substitutions are simple and few in number
% \item Lacks check that definitions are reasonable (positivity)
\item Demonstrates that previous work scales to more advanced proofs
\end{itemize}
\end{frame}


\begin{frame}{Proposed work: From indexed to dependent types}
\begin{itemize}
\item Goal: move from indexed type theory (Beluga) to dependent type theory
\item Allows us to fill in \good $\,$ for last two problems?
\begin{itemize}
\item ``Universes'' to properly define logical relations
\item Directly supports reasoning about functions

 e.g. concatenation of contexts, functions from contexts to contexts instead of relations
\end{itemize}
\item My work to date provides reason to believe this is feasible

% \item We can represent intrinsically well-typed object logics with inductive types, but it's repetitive to do define and prove properties of substitution for each object logic. Solution: Implement one, canonical forms LF, in which many others fit. (e.g. show intrinsically typed STLC?)
% \item Refinement: Build this datatype and related operations into the theory so we can support an equational theory for it.
% \item Resulting theory looks like \textbf{dependently typed} Beluga
% \item Support universes (``necessary'' to justify logical relations)
% \item (predicative) polymorphism
\end{itemize}
\end{frame}

% \begin{frame}[fragile]{The problem with first order encodings}
% % \begin{verbatim}
% % data exp (G : ctx) : tp -> Set where
% %  v : var G T -> exp G T
% %  app : exp G (arr T S) -> exp G T -> exp G S
% %  lam : exp (G , T) S -> exp G (arr T S)
% % \end{verbatim}
% % \pause
% % \begin{alltt}
% % [_] : sub G' G -> exp G T -> exp G' T
% % [_]' : sub G' G -> sub G D -> sub G' D
% % \end{alltt}
% % \pause
% \begin{alltt}
% lem1 : [ [ \(\sigma1\) ]' \(\sigma2\) ] = [ \(\sigma1\) ] \(\circ\) [ \(\sigma2\) ]
% lem2 : [ \(\sigma\) , M ] \(\circ\) \(\uparrow\) = [ \(\sigma\) ]
% lem3 : [ id ]' \(\sigma\) = \(\sigma\)
% lem4 : [ id , N ] \(\circ\) [ \(\uparrow\) \(\sigma\), 1 ] = [ \(\sigma\) , N ]
% ...
% \end{alltt}
% This is tedious to do for each language we study!

% \end{frame}

\begin{frame}{Proposed work: From indexed to dependent types}{Step 1: How?}
\begin{itemize}
\item Type formers in (intensional) dependent type theory come with \textbf{definitional equalities}
\begin{itemize}
\item Equalities which are proven automatically during proof checking
\item Definitional equality must be \emph{decidable} in order for type checking to be decidable
\end{itemize}
\item LF has proven to be well-suited for encoding binding and substitution
\item Proposed approach: provide a special built-in type of LF derivations in a dependent type theory
\begin{itemize}
\item Include equational theory of substitutions in definitional equality
\item Technical challenge: design an algorithm for deciding the resulting definitional equality and prove it correct
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Proposed work: From indexed to dependent types}{Step 1: How? cont'd}
\begin{itemize}
\item This is similar to the approach taken in Beluga, but dependent type theory introduces complications:
\item Definitional equality now includes also \textbf{computation} rules
\item Proving decidability typically also results in proofs of normalization and logical consistency
\item Proof requires more sophisticated \textbf{semantic} techniques
\item Approach: adapt proof for ``plain'' dependent type theory with a universe [Abel '11] to include equational theory of substitutions
\item Follow approach by Allais et al. '13 for incorporating ``non-computational'' laws
\end{itemize}
\end{frame}

\begin{frame}{Proposed work: From indexed to dependent types}{Step 2: Implementation and use cases}
\begin{itemize}
\item Prototype implementation: adapt Beluga implementation
\item Use prototype to formalize advanced proofs e.g.:
\begin{itemize}
\item Soundness and completeness of a normalization by evaluation algorithm [Dybjer and Filinski '00]
\item Normalization for Martin-L\"of type theory with a universe [Coquand '98]
\item Logical relation for contextual equivalence [Dreyer et al '11]
\item Normalization for System F [Girard '89]
\end{itemize}
\end{itemize}
\end{frame}

% \begin{frame}{A solution?}
% \begin{itemize}
% \pause \item We know that LF works well to encode object languages...
% \pause \item So do this *once* for LF, and embed your OL inside
% \pause \item I've prototyped this in Agda
% \pause \item $>$48GB of memory to typecheck an example
% \pause \item And we still have to apply these lemmas manually and often compose several of them
% \pause \item Solution: build LF datatype into DTT and build lemmas into conversion check
% \pause \item Result: ``dependently typed Beluga''
% \pause \item Analyze LF objects by the induction principle you get from considering an inductive type representing LF
% \pause \item provides ``simple'' approach to semantics, termination (via eliminator for LF datatype)?
% \end{itemize}
% \end{frame}

% \begin{frame}{The metric for success}
% \begin{itemize}
% \item Algorithm for typechecking (decidability, soundness, completeness)
% \item Consequences: normalization, consistency
% \item Prototype implementation
% \item Formalize non-trivial proofs, e.g.
% \begin{itemize}
% \item C. Coquand's normalization proof for MLTT with a universe
% \item logical relation for contextual equivalence (parametricity)
% \item soundness and completeness of NbE
% \item normalization for System F?
% \end{itemize}
% \end{itemize}
% \end{frame}

\begin{frame}{Conclusion}
\begin{itemize}
\item Building a logical framework into dependent type theory using the two-level approach appears feasible
\item Substantial benefits: formalizing advanced results in programming language theory becomes within reach
\item Hopefully provides insights into how to incoporate other equational theories from other areas of application?
\end{itemize}
\end{frame}

\end{document}
