\documentclass{beamer}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\lstloadlanguages{ContextualML}
\lstset{language=ContextualML}

\lstset{literate={->}{{$\rightarrow~$}}2 %
                 {=>}{{$\Rightarrow~$}}2 %
                 {id}{{{\smartkeywordFmt id}}}1 % 3 $~$
                 {\\}{{$\lambda$}}1 %
                 {\\Pi}{{$\Pi$}}1 %
                 {\\Sigma}{{$\Sigma$}}1 %
                 {\\Pibox}{{$\Pibox$}}1 %
                 {\\psi}{{$\psi$}}1 %
                 {\\phi}{{$\phi$}}1 %
                 {\\sigma}{{$\sigma$}}1 %
                 {\\gamma}{{$\gamma$}}1 %
%                 {mlam}{{$\lambda^{\scriptscriptstyle\Box}$}}1 %
                 {mlam}{{$\lambda$}}1 %
                 {FN}{{$\Lambda$}}1 %
                 {<<}{\color{dGreen}}1 %
                 {>>}{\color{black}}1 %
               ,
               columns=[l]fullflexible,
%               basewidth=\zzlstwidth,
%               basicstyle=\Lstbasicstyle,
%               keywordstyle=\keywordFmt,
%               identifierstyle=\relax,
%               stringstyle=\relax,
%               commentstyle=\commentFmt,
               breaklines=true,
               breakatwhitespace=true,   % doesn't do anything (?!)
               mathescape=true,   % interprets $...$ in listing as math mode
%               tabsize=8,
    %           texcl=false
    }


\usetheme{Warsaw}
\title[]{Beluga$^\mu$ by example}
\author{Andrew Cave}
\date{Aug 2nd, 2011}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]{Beluga$^\mu$}
\begin{lstlisting}
nat : type.
z : nat.
s : nat -> nat.

datatype vec : nat[] -> ctype =
 nil : vec ([]. z)
 cons : {N:nat[]} -> bool[] -> vec ([]. N) -> vec ([]. s N)
 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure based evaluator}
\begin{lstlisting}
lam: (tm -> tm) -> tm.              
app: tm -> tm -> tm.
schema ctx = tm;

datatype clos :  ctype =
 cl : {\psi:ctx} -> tm[\psi,x:tm] -> (#tm[\psi] -> clos) -> clos

type envr \psi = #tm[\psi] -> clos
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure based evaluator}
\begin{lstlisting}
type envr \psi = #tm[\psi] -> clos

rec extend : {\psi:ctx} envr \psi -> clos -> envr (\psi, x:tm) =
fn env => fn c => fn X => case X of
| \psi,x:tm . x => c
| \psi,x:tm . #p .. => env (\psi. #p ..)

rec eval : {\psi:ctx} tm[\psi] -> envr \psi -> clos  =
fn e => fn env => case e of
| \psi. #p .. => env (\psi. #p ..)
| \psi. lam (\x. E .. x)  => cl (\psi,x:exp . E .. x) env
| \psi. app (E1 ..) (E2 ..) =>
 let cl (\phi,x:tm . E .. x) env' = eval (\psi. E1 ..) env
 in eval (\phi,x:tm . E .. x) (extend env' (eval (\psi. E2 ..)))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}

\begin{lstlisting}
tm : type.
lam: (tm -> tm) -> tm.              
app: tm -> tm -> tm.

schema ctx = tm;
\end{lstlisting}

\begin{lstlisting}
envr : type.
ctm : type.
clam : (envr -> ctm) -> ctm.
proj : envr -> nat -> ctm.
close : ctm -> envr -> ctm.
open : ctm -> (env -> ctm -> ctm) -> ctm
nil : envr.
create : envr -> ctm.
snoc : envr -> ctm -> envr.

schema cctx = ctm;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}

\begin{lstlisting}
rec addProjs : (\phi:cctx) (N:nat[]) (M:cexp[\phi,e:envr])
  -> cexp[e:envr] =
mlam \phi => mlam N => mlam M => case \phi of
| [] => [e:envr]. M e
| \phi,x:ctm => addProjs \phi (s N) (\phi,e. M .. (proj e N) e)

rec ctxToEnv : (\phi:cctx) envr[\phi] =
mlam \phi => case \phi of
| [] => []. nil
| \phi,x:ctm => let \phi. env .. = ctxToEnv \phi in
  \phi,x:ctm. snoc (env ..) x

datatype ctx_rel : ctx -> cctx -> ctype
| rnil : ctx_rel [] []
| rsnoc : {\psi \phi} -> ctx_rel \psi$\;$\phi
  -> ctx_rel (\psi,x:tm) (\phi,x:ctm)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}
\begin{lstlisting}
rec conv : {\psi:ctx} (\phi:cctx) -> ctx_rel \psi$\;$\phi$\;$-> tm[\psi]
  -> ctm[\phi] =
mlam \phi => fn cr => fn m => case m of
| \psi',x. x     => let rsnoc {\phi = \phi',x} _ = cr in \phi',x. x
| \psi',x. #p .. => let rsnoc {\phi = \phi',x} cr' = cr in 
 let \phi'. M .. = conv _ cr' (\psi'. #p ..) in \phi',x. M ..
| \psi. lam (\x. M .. x) =>
 let \phi, x. M' .. x = conv _ (rsnoc cr) (\psi,x. M .. x) in
 let [ev:envr]. M'' ev = addProjs (\phi,x) z (\phi, x:ctm, ev:envr. M' .. x) in
 let \phi. Env .. = ctxToEnv \phi in 
 \phi.  close (clam (\ev. M'' ev)) (Env ..)
| \psi. app (M ..) (N ..) =>
 let \phi. M' .. = conv _ cr (\psi. M ..) in
 let \phi. N' .. = conv _ cr (\psi. N ..) in
 \phi. open (M' ..) (\ev. \f. capp f (create (snoc ev (N' ..))))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
atomic_tp : type.
tp : type.
atomic : atomic_tp -> tp.
arr : tp -> tp -> tp.
prod : tp -> tp -> tp.
unit : tp.

neut : tp -> type.
norm : tp -> type.
nlam : (neut T -> norm S) -> norm (arr T S).
npair : norm T -> norm S -> norm (prod T S).
ntt : norm unit.

rapp : neut (arr T S) -> norm T -> neut S.
rproj1 : neut (prod T S) -> neut T.
rproj2 : neut (prod T S) -> neut S.
embed : neut (atomic P) -> norm (atomic P).
schema ctx = some [T:tp] neut T;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}

\begin{lstlisting}
type sub \psi \phi = {T:tp[]} -> #(neut T)[\psi] -> #(neut T)[\phi]

datatype sem : ctx -> tp[] -> ctype =
| syn : {\psi} {P:atomic_tp[]}
   -> (neut (atomic P))[\psi] -> sem \psi$\,$ (atomic P)
| slam : {\psi$\;$T S} ({\phi} -> sub \psi$\,$\phi -> sem \phi$\,$ T -> sem \phi$\,$ S)
   -> sem \psi$\,$ (arr T S)
| spair : {\psi T S} sem \psi$\,$T -> sem \psi$\,$S -> sem \psi$\,$(prod T S)
| stt : {\psi} sem \psi$\,$unit

rec subst:{\psi \phi$\,$ S} -> sub \psi$\;$\phi -> sem \psi$\,$ S -> sem \phi$\,$ S =
fn \sigma => fn e => case e of
| syn (\psi. R ..) => nsubst \sigma (\psi. R ..)
| slam f => slam (fn \sigma' => fn s => f (\sigma' $\circ$ \sigma) s)
| spair M N => spair (subst \sigma M) (subst \sigma N)
| stt => stt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
rec reflect : (\psi T) (R:(neut T)[\psi]) -> sem \psi$\,$T =
mlam \psi => mlam T => mlam R => case []. T of
| []. atomic P => syn (\psi. R ..) 
| []. arr T S => slam (mlam {\phi} => fn \sigma => fn s =>
 let \phi. R' .. = nsubst \sigma (\psi. R ..) in
 let \phi. N .. = reify _ T s in
 reflect _ S (\phi. rapp (R' ..) (N ..)))
| []. prod T S =>
  spair (reflect _ T (\psi. nproj1 (R ..)))
        (reflect _ S (\psi. nproj2 (R ..)))
| []. unit => stt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
rec weaken : {\psi:ctx} {S:tp[]} -> sub \psi (\psi,x:tm S) =
fn y => case y of
| \psi. #p .. => \psi,x:neut _. #p ..

rec reify : (\psi T) -> sem \psi$\,$ T -> (norm T)[\psi] = 
mlam \psi => mlam T => fn s => case []. T of 
| []. atomic P => let syn (\psi. R ..) = s
 in \psi. embed (R ..)
| []. arr T S => let slam f = s in
 let \psi,x:tm T. E .. x =  
   reify (f weaken (reflect _ T (\psi,x:neut T. x)))
 in \psi. nlam (\x. E .. x)
| []. prod T S => let spair m n = s in
 let \psi. M .. = reify _ T m in
 let \psi. N .. = reify _ S n in
 \psi. npair (M ..) (N ..)
| []. unit => \psi. ntt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
tm : tp -> type.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).
proj1 : tm (prod T S) -> tm T
proj2 : tm (prod T S) -> tm S
pair : tm T -> tm S -> tm (prod T S).
tt : tm unit.
schema tctx = some [T:tp] tm T;
\end{lstlisting}
\end{frame}

\end{document}
