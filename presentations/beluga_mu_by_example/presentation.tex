\documentclass{beamer}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{alltt}
\newdimen\zzlistingsize
\newdimen\zzlistingsizedefault
\zzlistingsizedefault=9pt
\zzlistingsize=\zzlistingsizedefault
\global\def\InsideComment{0}
\newcommand{\keywordFmt}{\fontsize{0.9\zzlistingsize}{1.0\zzlistingsize}\bf}
\newcommand{\smartkeywordFmt}{\if0\InsideComment\keywordFmt\fi}

\lstloadlanguages{ContextualML}
\lstset{language=ContextualML}

\lstset{literate={->}{{$\rightarrow~$}}2 %
                 {=>}{{$\Rightarrow~$}}2 %
                 {id}{{{\smartkeywordFmt id}}}1 % 3 $~$
                 {\\}{{$\lambda$}}1 %
                 {\\Pi}{{$\Pi$}}1 %
                 {\\Sigma}{{$\Sigma$}}1 %
                 {\\Pibox}{{$\Pibox$}}1 %
                 {\\psi}{{$\psi$}}1 %
                 {\\phi}{{$\phi$}}1 %
                 {\\sigma}{{$\sigma$}}1 %
                 {\\gamma}{{$\gamma$}}1 %
%                 {mlam}{{$\lambda^{\scriptscriptstyle\Box}$}}1 %
                 {mlam}{{$\lambda$}}1 %
                 {FN}{{$\Lambda$}}1 %
                 {<<}{\color{dGreen}}1 %
                 {>>}{\color{black}}1 %
               ,
               columns=[l]fullflexible,
%               basewidth=\zzlstwidth,
%               basicstyle=\Lstbasicstyle,
%               keywordstyle=\keywordFmt,
%               identifierstyle=\relax,
%               stringstyle=\relax,
%               commentstyle=\commentFmt,
               breaklines=true,
               breakatwhitespace=true,   % doesn't do anything (?!)
               mathescape=true,   % interprets $...$ in listing as math mode
%               tabsize=8,
    %           texcl=false
    }


\usetheme{Warsaw}
\title[]{Beluga$^\mu$ by example}
\author{Andrew Cave}
\date{Aug 2nd, 2011}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]{Beluga$^\mu$}
\begin{lstlisting}
nat : type.
z : nat.
s : nat -> nat.

datatype vec : nat[] -> ctype =
 nil : vec ([]. z)
 cons : {N:nat[]} -> bool[] -> vec ([]. N) -> vec ([]. s N)
 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure based evaluator}
\begin{lstlisting}
lam: (tm -> tm) -> tm.              
app: tm -> tm -> tm.
schema ctx = tm;

datatype clos :  ctype =
 cl : {\psi:ctx} -> tm[\psi,x:tm] -> (#tm[\psi] -> clos) -> clos

type envr \psi = #tm[\psi] -> clos
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure based evaluator}
\begin{lstlisting}
type envr \psi = #tm[\psi] -> clos

rec extend : {\psi:ctx} envr \psi -> clos -> envr (\psi, x:tm) =
fn env => fn c => fn x => case x of
| \psi,x:tm . x => c
| \psi,x:tm . #p .. => env (\psi. #p ..)

rec eval : {\psi:ctx} tm[\psi] -> envr \psi -> clos  =
fn e => fn env => case e of
| \psi. #p .. => env (\psi. #p ..)
| \psi. lam (\x. E .. x)  => cl (\psi,x:exp . E .. x) env
| \psi. app (E1 ..) (E2 ..) =>
 let cl (\phi,x:tm . E .. x) env' = eval (\psi. E1 ..) env
 in eval (\phi,x:tm . E .. x) (extend env' (eval (\psi. E2 ..)))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}
Let's make closures explicit so that we can hoist them to the top level and compile them.

\begin{alltt}
let x = 5
    y = 2
    f = \(\lambda\)z. x + y + z in
  f 1
\end{alltt}

Becomes:

\begin{alltt}
let x = 5
    y = 2
    f' =
 clos (\(\lambda\)ev. (\(\pi\) 1 ev) + (\(\pi\) 2 ev) + (\(\pi\) 3 ev)) < x , y > in
 open f' (\(\lambda\)(f,ev). f < ev , 1 >)
\end{alltt}

The source language and the target language are substantially different.
\end{frame}

\begin{frame}[fragile]{Closure conversion}

\begin{lstlisting}
tm : type.
lam: (tm -> tm) -> tm.              
app: tm -> tm -> tm.

schema ctx = tm;
\end{lstlisting}

\begin{lstlisting}
envr : type.
ctm : type.
clam : (envr -> ctm) -> ctm.
proj : envr -> nat -> ctm.
close : ctm -> envr -> ctm.
open : ctm -> (env -> ctm -> ctm) -> ctm
nil : envr.
create : envr -> ctm.
snoc : envr -> ctm -> envr.

schema cctx = ctm;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}

\begin{lstlisting}
rec addProjs : (\phi:cctx) (N:nat[]) (M:cexp[\phi,e:envr])
  -> cexp[e:envr] =
mlam \phi => mlam N => mlam M => case \phi of
| [] => [e:envr]. M e
| \phi,x:ctm => addProjs \phi (s N) (\phi,e. M .. (proj e N) e)
e.g. addProjs _ z ([x:ctm,y:ctm,e:envr]. app x y)
 yields [e:envr]. app (proj e (s z)) (proj e z)

rec ctxToEnv : (\phi:cctx) envr[\phi] =
mlam \phi => case \phi of
| [] => []. nil
| \phi,x:ctm => let \phi. env .. = ctxToEnv \phi in
  \phi,x:ctm. snoc (env ..) x
e.g. ctxToEnv (x:ctm,y:ctm,z:ctm)
 yields [x:ctm,y:ctm,z:ctm]. snoc (snoc (snoc nil x) y) z

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}
\begin{lstlisting}
datatype ctx_rel : ctx -> cctx -> ctype
| rnil : ctx_rel [] []
| rsnoc : {\psi \phi} -> ctx_rel \psi$\;$\phi -> ctx_rel (\psi,x:tm) (\phi,x:ctm)
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Closure conversion}
\begin{lstlisting}
rec conv : {\psi:ctx} (\phi:cctx) -> ctx_rel \psi$\;$\phi$\;$-> tm[\psi] -> ctm[\phi] =
mlam \phi => fn cr => fn m => case m of
| \psi',x. x     => let rsnoc {\phi = \phi',x} _ = cr in \phi',x. x
| \psi',x. #p .. => let rsnoc {\phi = \phi',x} cr' = cr in 
 let \phi'. M .. = conv _ cr' (\psi'. #p ..) in \phi',x. M ..
| \psi. lam (\x. M .. x) =>
 let \phi, x. M' .. x = conv _ (rsnoc cr) (\psi,x. M .. x) in
 let [ev:envr]. M'' ev = addProjs (\phi,x) z (\phi, x:ctm, ev:envr. M' .. x) in
 let \phi. Env .. = ctxToEnv \phi in 
 \phi.  close (clam (\ev. M'' ev)) (Env ..)
| \psi. app (M ..) (N ..) =>
 let \phi. M' .. = conv _ cr (\psi. M ..) in
 let \phi. N' .. = conv _ cr (\psi. N ..) in
 \phi. open (M' ..) (\ev. \f. capp f (create (snoc ev (N' ..))))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Closure conversion}
How about type preserving closure conversion?

\begin{lstlisting}
tp_rel : tp -> ctp -> type.
i_rel : tp_rel i i'
arr_rel : tp_rel T T' -> tp_rel S S'
  -> tp_rel (arr T S) (clos T' S')

type ctx_rel : ctx -> cctx -> ctype =
| rnil : ctx_rel [] []
| rsnoc : {\psi \phi} {T:tp[]} {S:ctp[]} -> ctx_rel \psi$\,$ \phi
  -> tp_rel T S -> ctx_rel (\psi, x:tm T) (\phi, x:ctm S)
\end{lstlisting}

(Unfortunately) now we have to prove lemmas which say that \lstinline!tp_rel! and \lstinline!ctx_rel! are total and deterministic.
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
We want to normalize lambda terms. (e.g. we are type-checking a PTS with dependent types) 
\begin{align*}
(\lambda x. M) N &\equiv_{\beta_{arrow}} [N/x]M\\
M : T \rightarrow S &\equiv_{\eta_{arrow}} \lambda x. M x\\
\pi_1 (M , N) &\equiv_{\beta_{prod_1}} M\\
\pi_2 (M , N) &\equiv_{\beta_{prod_2}} N\\
M : T \times S &\equiv_{\eta_{prod}} (\pi_1 M, \pi_2 M)\\
M : unit &\equiv_{\eta_{unit}} tt
\end{align*}

A closed term of type {\tt unit} will always be equal to {\tt tt} using only $\beta$, but we'd like to work with terms in non-empty contexts.

That is, we'd like to identify $\lambda x:\text{unit} \lambda y:\text{unit}. x$ and $\lambda x:\text{unit} \lambda y:\text{unit}. y$.

With $\eta_{unit}$, these are both equal to $\lambda x:\text{unit} \lambda y:\text{unit}. tt$.

Normalization by evaluation reuses the evaluation of the meta-language and gets us $\beta$ \emph{and} $\eta$.
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
tp : type.
atomic : atomic_tp -> tp.
arr : tp -> tp -> tp.
prod : tp -> tp -> tp.
unit : tp.

neut : tp -> type.
norm : tp -> type.
embed : neut (atomic P) -> norm (atomic P).
nlam : (neut T -> norm S) -> norm (arr T S).
npair : norm T -> norm S -> norm (prod T S).
ntt : norm unit.

rapp : neut (arr T S) -> norm T -> neut S.
rproj1 : neut (prod T S) -> neut T.
rproj2 : neut (prod T S) -> neut S.
schema ctx = some [T:tp] neut T;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}

\begin{lstlisting}
type sub \psi \phi = {T:tp[]} -> #(neut T)[\psi] -> #(neut T)[\phi]

datatype sem : ctx -> tp[] -> ctype =
| syn : {\psi} {P:atomic_tp[]}
   -> (neut (atomic P))[\psi] -> sem \psi$\,$ (atomic P)
| slam : {\psi$\;$T S} ({\phi} -> sub \psi$\,$\phi -> sem \phi$\,$ T -> sem \phi$\,$ S)
   -> sem \psi$\,$ (arr T S)
| spair : {\psi T S} sem \psi$\,$T -> sem \psi$\,$S -> sem \psi$\,$(prod T S)
| stt : {\psi} sem \psi$\,$unit

rec subst:{\psi \phi$\,$ S} -> sub \psi$\;$\phi -> sem \psi$\,$ S -> sem \phi$\,$ S =
fn \sigma => fn e => case e of
| syn (\psi. R ..) => nsubst \sigma (\psi. R ..)
| slam f => slam (fn \sigma' => fn s => f (\sigma' $\circ$ \sigma) s)
| spair M N => spair (subst \sigma M) (subst \sigma N)
| stt => stt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
rec reflect : (\psi T) (R:(neut T)[\psi]) -> sem \psi$\,$T =
mlam \psi => mlam T => mlam R => case []. T of
| []. atomic P => syn (\psi. R ..) 
| []. arr T S => slam (mlam {\phi} => fn \sigma => fn s =>
 let \phi. R' .. = nsubst \sigma (\psi. R ..) in
 let \phi. N .. = reify _ T s in
 reflect _ S (\phi. rapp (R' ..) (N ..)))
| []. prod T S =>
  spair (reflect _ T (\psi. nproj1 (R ..)))
        (reflect _ S (\psi. nproj2 (R ..)))
| []. unit => stt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
rec weaken : {\psi:ctx} {S:tp[]} -> sub \psi (\psi,x:tm S) =
fn y => case y of
| \psi. #p .. => \psi,x:neut _. #p ..

rec reify : (\psi T) -> sem \psi$\,$ T -> (norm T)[\psi] = 
mlam \psi => mlam T => fn s => case []. T of 
| []. atomic P => let syn (\psi. R ..) = s
 in \psi. embed (R ..)
| []. arr T S => let slam f = s in
 let \psi,x:tm T. E .. x =  
   reify (f weaken (reflect _ T (\psi,x:neut T. x)))
 in \psi. nlam (\x. E .. x)
| []. prod T S => let spair m n = s in
 let \psi. M .. = reify _ T m in
 let \psi. N .. = reify _ S n in
 \psi. npair (M ..) (N ..)
| []. unit => \psi. ntt
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
Aside: We can now write these with relative ease:
\begin{lstlisting}
type nsub (\psi:ctx) (\phi:ctx) =
  {T:tp[]} #(neut T)[\psi] -> (norm T)[\phi]

rec nembed : {\psi T} (norm T)[\psi] -> sem \psi$\,$T = ...

rec cut :{\psi \phi:ctx} {T} (norm T)[\psi] -> nsub \psi$\,$\phi -> (norm T)[\phi]
= ...
-- This is a different algorithm for hereditary substitution

rec single : {\psi T} (norm T)[\psi] -> sub (\psi, x:neut T)$\,$\psi
= ...

rec napp : {\psi:ctx} {T S} (norm (arr T S))[\psi] -> (norm T)[\psi] -> (norm S)[\psi]
fn n => fn m => case n of
| \psi. nlam (\x. N .. x) => cut (single m) (\psi,x:neut _. N .. x)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
tm : tp -> type.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).
proj1 : tm (prod T S) -> tm T
proj2 : tm (prod T S) -> tm S
pair : tm T -> tm S -> tm (prod T S).
tt : tm unit.
schema tctx = some [T:tp] tm T;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
type sSub (\psi:tctx) \phi = {T} #(tm T)[\psi] -> sem \phi$\,$ T
rec eval : {\psi \phi$\;\;$S} -> sSub \psi$\,$\phi -> (tm S)[\psi] -> sem \phi$\,$S =
fn r => fn \sigma => fn e => case e of 
| \psi. #p ..  => \sigma ($\psi$ . #p .. )
| \psi. lam (\x. E .. x) => slam (fn \sigma' => fn s =>
    eval (extend ((subst \sigma') $\circ$ \sigma) s) (\psi,x. E .. x)
| \psi. app (E1 ..) (E2 ..) =>  let slam f = eval \sigma (\psi. E1 ..) in
   f id (eval \sigma (\psi. E2 ..))

rec nbe : {T} -> (tm T)[\psi] -> (norm T)[\psi] = 
fn e => reify [] T (eval (fn x => reflect _ _ x) e)

\sigma  : sSub \psi$\,$\phi
\sigma' : sSub \phi$\,\chi$
-----------------------
(subst \sigma') $\circ$ \sigma$\quad$:$\quad$sSub \psi$\,\,\chi$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Normalization by Evaluation}
\begin{lstlisting}
rec extend : {\psi:tctx} {\phi:ctx} {T}
  -> sSub \psi \phi -> sem \phi$\,$T -> sSub (\psi,x:tm T) \phi
fn \sigma => fn s => fn y => case y of
| \psi,x:tm S. => s
| \psi,x:tm S. #p .. =>  \sigma (\psi. #p ..)
\end{lstlisting}
\end{frame}

\end{document}
